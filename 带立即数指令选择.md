## 通过tablegen开展带立即数指令选择
指令选择最常见的方式是通过在tablengen中定义`pattern`的正则表达式，将对应的DAG节点lower为面向Target的指令。
本文将以RISCV::BNEI指令介绍指令选择阶段最为通用的`Select()`实现。

### 指令介绍
`BNEI`指令为RISCV::BNE指令的立即数加强版本，若匹配的变量为立即数时可以使用`BNEI`指令来进行指令执行，达到指令数量压缩的目的。
在Tablegen中关于BNEI的指令描述如下:
```c++
class BranchCC_rii<bits<3> funct3, string opcodestr>
    : RVInstSB<funct3, OPC_CUSTOM_0, (outs),
              (ins GPR:$rs1, simm8:$cmp_imm8, simm10_lsb0:$offset),
              opcodestr, "$rs1, $cmp_imm8, $offset">,
              Sched<[WriteJmp, ReadJmp, ReadJmp]> {
  let isBranch = 1;
  let isTerminator = 1;
}
def BNEI  : BranchCC_rii<0b001, "bnei">;
```

该指令的指令选择方式通过tablgen的`Pattern`的方式进行定义，正则匹配格式如下所示，通过匹配`BR_CC`节点和操作数为立即数，即可匹配为BNEI的指令。
```c++
multiclass BcciPat<CondCode Cond, RVInstSB Inst> {
  def : Pat<(riscv_brcc GPR:$rs1, simm8:$cmp_imm8, Cond, bb:$imm9),
            (Inst GPR:$rs1, simm8:$cmp_imm8, simm10_lsb0:$imm9)>;
}
defm : BcciPat<SETNE, BNEI>;
```

### 指令选择过程
BNEI指令作为一个经典通用的指令选择过程，其将在`RISCVISelDAGToDAG.cpp`中的`Select()`函数中执行`SelectCode(Node)`动作来实现。
`SelectCode`的具体实现在`RISCVGenDAGISel.inc`文件中定义。该`.inc`文件由tablegen生成的指令选择表，通过查表行为完成实质上的pattern表达式匹配过程。
指令选择过程可以通过`-debug-only=isel`输出的日志可以查看。
以BNEI节点的指令选择过程举例：
1. 通过搜寻`BR_CC`节点，找到`.inc`文件中指令表的起始行号为`Initial Opcode index to 1260996`。
该log表示以当前的`BR_CC`节点获取对应的`MatchIndex`，从该位置开始往下进行表行为执行令。如果执行逻辑需要跳转，将通过+offset的方式跳转到后续的对应行数。LLVM非常喜欢使用类似的表项结构来进行查表逻辑，包括但不限于指令选择、译码、解码等。

2. 查表与执行。如下表和对应的行为举例可知，通过查表进行对应的操作数获取和操作数内容检查，进而确定最终的指令为`BNEI`
```
/*1260996*/  OPC_RecordNode, // #0 = 'riscv_brcc' chained node    // 获取对应BR_CC节点
/*1260997*/  OPC_RecordChild1, // #1 = $rs1                       // 获取操作数1
/*1260998*/  OPC_Scope, 25|128,4/*537*/, /*->1261538*/ // 2 children in Scope   //跳转节点，看要跳多远
/*1261001*/   OPC_CheckChild1Type, MVT::i64,                      // 调到此处检查操作数1的类型是否为i64,不是调到检查i32
/*1261540*/   OPC_CheckChild1Type, MVT::i32,                      // 确实是i32, 顺序执行
/*1261542*/   OPC_Scope, 21|128,1/*149*/, /*->1261694*/ // 2 children in Scope
/*1261545*/    OPC_CheckChild2Integer, 0, 
/*1261696*/    OPC_RecordChild2, // #2 = $cmp_imm8                // 操作数2
/*1261780*/       OPC_MorphNodeTo0, TARGET_VAL(RISCV::BNEI), 0|OPFL_Chain,
```

#### 常数节点转GPR节点
我们知道`BNEI`节点的立即数是有范围要求的，只能是一个8bit的有符号数。如果常数节点的立即数大于8bit，编译器将从BENI指令改为选择BNE指令。值得注意的是，BNE指令要求操作数为GPR，而不是立即数。则意味着常数节点需要被lower为一个GPR节点。

在LLVM编译器指令选择过程中，将对ISD::Constant类型的节点进行常数节点选择，
通过 ReplaceNode(Node, selectImm(CurDAG, DL, VT, Imm, *Subtarget)); 将常数节点使替换为一个带有操作指令的新节点(一般为ADDI，LUI，LI指令)，该新节点的输出为一个GPR。该替换函数为`ReplaceNode(Node, selectImm(CurDAG, DL, VT, Imm, *Subtarget));`


请注意，所有的`Constant`类型节点都需要被lower为一个带有GPR输出的节点。但是，在执行指令选择时可知，新指令的源操作为立即数，其DAG节点不再是Constant类型，而是`TargetConstant`类型。在LLVM编译器中，有对TargetConstatn有详细描述：
>>  /// TargetConstant* - Like Constant*, but the DAG does not do any folding, simplification, or lowering of the constant. They are used for constants。

如上可知，`TargetConstant`节点是Constant节点的lower后的形式，换而言之，`Constant`类型节点将会被指令选择，而`TargetConstant`类型节点不会被指令选择，会被保留。

一般而言，在指令选择过程中，`Constant`DAG节点和其UseList的DAG节点存在先后排布顺序关系。LLVM会优先处理UseList的DAG节点，后处理与之相关的`Constant`DAG节点，这带来的效果就是：以BNEI指令为例，其会新构建一个类型为`TargetConstant`的DAG节点替代原`Constant`DAG节点作为其立即数的源操作数，原`Constant`节点将会被作为deadNode被删除。如果删除不了，则意味着其需要被lower为一个类似`ADDI，zero， imm`的指令。
