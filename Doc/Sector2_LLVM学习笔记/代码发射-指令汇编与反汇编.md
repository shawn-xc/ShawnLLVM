## 指令汇编与反汇编处理
`clang`或者`llc`编译器命令可将c源代码或`llvm ir`编译为`.o`的二进制汇编文件，`.o`文件可以通过`llvm-objdump`命令进行反汇编。
在执行`llvm-objdump`反汇编时，有时我们可能会看到类似`<unknown>`的反汇编输出，该输出显示某条指令反汇编失败。

鉴于此场景，我们简单介绍下面向目标机器环境(`Target`)下LLVM编译器框架的汇编与反汇编流程。

### 1 `.o`对象文件的结构
#### 1.1 对象文件结构
`.o`二进制文件不仅包含了机器码，还包含有其他一些内容细节。二进制文件中通常包含如下内容：
* `Header`：这是一个包含各种符号和元数据的结构，用于指示操作系统如何加载和链接目标文件。
* `Text section`：这是包含实际机器码的部分，通常包含函数和全局变量的定义。这是程序的主要执行部分，并且是链接和执行程序所必需的。
* `Data section`：这是一个包含程序中初始化的静态数据的部分，例如全局变量的初始值。
* `BSS section`：这是一个包含未初始化的静态数据的部分，如全局变量等。它只是分配空间，在程序加载时将其初始化为0。
* `Relocation table`：这是一个包含链接器用于链接程序的信息的部分。它包括一堆地址，每个地址都指向一个程序中的符号，这些符号在链接时必须被解析。

#### 1.2 `ELF`头部
如上所示的二进制文件结构，我们最关系的内容就是**目标机器编译信息**和**指令机器码**，它们分别在`Header`部分和`Text Section`部分。
`Header`部分内容包含了文件类型、目标体系结构(`Triple`|`cpu`|`Feature`)、入口点、版本信息等。如下为通过`llvm-objdump`查看的`Header`内容。
```bash
$llvm-objdump -h ebset1.o
ebset1.o:       file format elf32-bigriscv
Sections:
Idx Name              Size     VMA      Type
  0                   00000000 00000000 
  1 .strtab           00000050 00000000 
  2 .text             00000034 00000000 TEXT
  3 .comment          00000080 00000000 
  4 .note.GNU-stack   00000000 00000000 
  5 .riscv.attributes 0000001c 00000000 
  6 .symtab           00000030 00000000
```

#### 1.3 机器码
在`Text Section`存放机器指令的机器码内容，请注意机器码在二进制中存放是小端模式(低地址低字节)，可以通过`llvm-objdump`查看机器码的内容。
```bash
$ llvm-objdump -d ebset1_para.o
ebset1_para.o:  file format elf32-bigriscv
Disassembly of section .text:
00000000 <main>:
       0: 13 01 01 fe   addi    sp, sp, -32
       4: 23 2e 11 00   sw      ra, 28(sp)
       8: 23 2c 81 00   sw      s0, 24(sp)
       c: 13 04 01 02   addi    s0, sp, 32
      10: 23 2a 04 fe   sw      zero, -12(s0)
```


### 2 目标机器参数确定
汇编过程是将指令发射为面向具体目标机器的机器码，因而汇编过程需要清楚的指导目标机器的关键参数，这个参数通常而言就是LLVM后端三要素信息:{`Target`,`CPU`,`Feature`}。
无论是汇编过程还是反汇编过程都是需要知道上述三要素信息的。
目标机器参数需要通过命令行参数的方式传递给编译器。
#### 2.1 `clang`参数
**TBD**

#### 2.2 `llc`参数
`llc`参数比较简单,`-march=`用于控制目标端，`-mcpu=`用于控制处理器，`-mattr=`用于控制指令特性。
`llc`如果不添加上述信息，则会使用`LLVM-IR`内置参数进行汇编`.s`文件生成。`llc`目标机器参数的注入主要是为了让`.o`文件的`header`信息携带正确的目标机器参数，方便反汇编使用。

请注意，再次强调下，我们需要修改掉一个思维惯性: **LLVM-IRM中标记的`attribute`信息并不会用于帮助生成反汇编内容。** 这句规则包含了3个信息：
1.  生成汇编二进制文件时，机器码是代码生成可以依赖`LLVM-IR`的内容;
2.  生成汇编二进制文件时，`ELF`头信息的代码生成不依赖`LLVM-IR`的内容；
3.  反汇编机器码会依赖`ELF`头信息，头信息的缺失或者不对等将导致反汇编出现`<unkonwn>`
```bash
llc demo.ll -march=riscv32be -mcpu=yaoling -mattr=+c
```

### 3 汇编生成器
LLVM编译器汇编过程可简单理解为将机器指令`MCInstr`代码发射的过程，除了关键的代码发射步骤，还有一些其他的优化措施，比如机器码压缩。
#### 3.1 代码发射
机器码发射是将`MCInst`机器码指令发射为汇编文件内容，代码在·RISCVAsmPrinter.cpp·中开始执行。其关键函数为：
`RISCVMCCodeEmitter.cpp`中的`encodeInstruction()`，该函数将实现具体的机器码封装并写入`ELF`文件系统。
```c++
tbd
```

#### 3.2 机器码压缩
在汇编过程中，如果当前机器指令可以使用更小位宽的机器指令来替代，则会执行机器码压缩操作。机器码压缩发生在代码发射过程：
```c++
void RISCVAsmPrinter::EmitToStreamer(MCStreamer &S, const MCInst &Inst) {
  MCInst CInst;
  bool Res = RISCVRVC::compress(CInst, Inst, *STI);
  if (Res)
    ++RISCVNumInstrsCompressed;
  AsmPrinter::EmitToStreamer(*OutStreamer, Res ? CInst : Inst);
}
```
如上代码可以看出，通过`comperss()`函数的调用，运行编译器将原有32bit指令替换为16bit指令，达到节省资源的目的。

### 4 反汇编生成器
反汇编过程是从`.o`文件中获取目标机器的指令特性信息,进而对机器码记性译码输出指令内容。

#### 4.1 获取目标机器参数
以`RISCV`为例，`RISCVSAInfo::parseArchString()`将针对`.o`中获取的字符串进行指令特性解析。假定该函数的参数`arch`字符串为`rv32i2p0_m2p0_a2p0_snp1p0`,即代表其机器码指令使用了`RISCV`的`i`,`m`,`a`,`snp`指令特性。
```c++
```

#### 4.1 构建反汇编器
```c++
extern "C" LLVM_EXTERNAL_VISIBILITY void LLVMInitializeRISCVDisassembler() {
  // Register the disassembler for each target.
  TargetRegistry::RegisterMCDisassembler(getTheRISCV32Target(),
                                         createRISCVDisassembler);
  TargetRegistry::RegisterMCDisassembler(getTheRISCV64Target(),
                                         createRISCVDisassembler);
  TargetRegistry::RegisterMCDisassembler(getTheRISCV32beTarget(),
                                         createRISCVDisassembler);
  TargetRegistry::RegisterMCDisassembler(getTheRISCV64beTarget(),
                                         createRISCVDisassembler);
}
```

#### 4.3 机器码译码
在获取机器码之后，接下来要做的就是针对机器码进行译码，以32bit机器码举例说明。LLVM编译器将构建一个译码表`DecodeTable32`,反汇编器将通过查该表去了解接下来索要做的动作。一般的动作包括：
1. `OPC_ExtractField` 域段内容获取，根据参数列表获取对应域段的值；
2. `OPC_FilterValue`  过滤器，将域段内容与过滤器中的参数进行比对；若命中则执行当前table表的下一行表内容；否则则根据过滤器的其他参数跳转到table表的对应行。
3. `OPC_Decode` 译码器，根据译码器参数计算出具体操作码；该行行为一般跟在过滤器之后执行，即上一行的过滤器比对成功就会执行本行的译码器。
如下为一段`DecoderTable32`代码演示：
```c++
static const uint8_t DecoderTable32[] = {
/* 0 */       MCD::OPC_ExtractField, 0, 7,  // Inst{6-0} ...
//            从0bit开始，获取7bit数据
/* 3 */       MCD::OPC_FilterValue, 3, 76, 0, 0, // Skip to: 84
              // 根据3，算出了Len=1，val = 3, ptr跳转+Len
              // 76: NumtoSkip,
              // 0: NumToSkip OR 8bit开始的赋值OR 
              // 0: NumToSkip OR 16bit开始的赋值OR
              // Val 将会与上一次取的Field做匹配，match,不match就往下调 也就是注释部分：
/* 8 */       MCD::OPC_ExtractField, 12, 3,  // Inst{14-12} ...
/* 11 */      MCD::OPC_FilterValue, 0, 4, 0, 0, // Skip to: 20
/* 16 */      MCD::OPC_Decode, 130, 97, 33, // Opcode: LB
```

#### 4.4 `ADDI`指令译码
以`ADDI`为例，我们有一条汇编指令`addi sp sp -32`, 其机器码为`0xFE010113`,其opcode为`19`。
另，`ADDI`的机器码需要关注`opcode{7:0`}以及`funct3{14:12}`；此两者为其机器码解码的跳转逻辑。
```c++
// Opcod查找和命中，第一个值为需要命中的值，后面的三个值为下一跳的计算参数
/* 3 */       MCD::OPC_FilterValue, 3, 76, 0, 0, // Skip to: 84
/* 84 */      MCD::OPC_FilterValue, 7, 114, 11, 0, // Skip to: 3019
/* 3019 */    MCD::OPC_FilterValue, 11, 87, 0, 0, // Skip to: 3111
/* 3111 */    MCD::OPC_FilterValue, 15, 124, 0, 0, // Skip to: 3240
/* 3240 */    MCD::OPC_FilterValue, 19, 106, 2, 0, // Skip to: 3863

//命中后，解码funct3{14:13}，获取其值为0
/* 3245 */    MCD::OPC_ExtractField, 12, 3,  // Inst{14-12} ...

// 0值将进行FilterValue方式进行match; 首行就命中了
/* 3248 */    MCD::OPC_FilterValue, 0, 4, 0, 0, // Skip to: 3257

// 命中后，就需要进行译码，OPC_Decode；通过199计算出其ADDI的枚举为11975
/* 3253 */    MCD::OPC_Decode, 199, 93, 33, // Opcode: ADDI


```

#### 4.5 解码GPR寄存器

```c++
static DecodeStatus DecodeGPRRegisterClass(MCInst &Inst, uint64_t RegNo,
                                           uint64_t Address,
                                           const MCDisassembler *Decoder) {
  const FeatureBitset &FeatureBits =
      Decoder->getSubtargetInfo().getFeatureBits();
  bool IsRV32E = FeatureBits[RISCV::FeatureRV32E];

  if (RegNo >= 32 || (IsRV32E && RegNo >= 16))
    return MCDisassembler::Fail;

  MCRegister Reg = RISCV::X0 + RegNo;
  Inst.addOperand(MCOperand::createReg(Reg));
  return MCDisassembler::Success;
}
```
