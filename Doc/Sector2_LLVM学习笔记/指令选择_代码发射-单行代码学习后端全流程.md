# 一行代码学习llvm的指令选择过程

`LLVM`后端是一个非常复杂的流程，从指令选择到最后的汇编代码发射需要经过许多的步骤。在这之前，我们或多或少通过`后端代码codegen`等文章对LLVM后端有了一定的理解，接下来我们通过一个最简单的例子来入手，示例LLVM面向CPU0目标环境的后端流程。

### 1 源代码

首先编写一个非常简单的c代码，名字就叫`test.cpp`，先写一个简单的操作：

```cpp
int div(int a, int b){
  return a/b;
}
```

上述代码是一个非常简单的除法操作，不过在CPU0目标机器并不直接支持一般的除法指令，所以在指令选择阶段需要进行一定的处理。

### 2 生成LLVM-IR
源代码生产LLVM-IR使用如下命令,请注意`-emit-llvm`参数，该参数将C代码生成为LLVM的中间表示`.ll`文件。
```bash
clang -O2 -S test.cpp -emit-llvm -o tset.ll
```
`test.ll`中的主要内容展示如下,我们可以除法指令表示为`sdiv`，这是`llvm-ir`中的除法指令语法方式。
```c++
define i32 @_Z3divii(i32 signext, i32 signext) local_unnamed_addr #0 {
  %3 = sdiv i32 %0, %1
  ret i32 %3
}
```


### 2 指令选择

指令选择的各个阶段可以简单概括如下，我们演示每个阶段展示除法运算的表达形式和对应的代码。
![is.imag](picture/%E6%8C%87%E4%BB%A4%E9%80%89%E6%8B%A9.drawio.png)
我们可以通过`llc`命令将LLVM-IR发射为汇编代码，如下命令行所示:
```bash
llc -O2 -march=cpu0 --debug-only=isel test.ll >test.log 2>&1
```
这条命令会把指令选择阶段的`SelectionDAG`打印到`test.log`文件中，并会表明每个阶段的状态。另外，还可以加上`-view-dag-combine1-dags`等命令，将对应阶段的SelectionDAG图画出来。

**1 SelectionDAG构建**

在初始的SelectionDAG中，sdiv操作被表示成了:
```c++
t5: i32 = sdiv t2, t4
```
这一条就是SelectionDAG中的一个节点，其中`t5`、`t2`、`t4`是节点自动命名的名字，`t2`，`t4`是接受的输入，`i32`表示返回值类型，此时的`sdiv`已转为DAG节点的形式，也就是`SDNode`的数据结构，在`llvm/include/llvm/Target/TargetSelectionDAG.td`中可以找到下面一行:
```c++
def sdiv:SDNode<“ISD::SDIV”, SDTFPBinOp>;
```
这是一条tablegen语言，`SDNode`是LLVM提供的类，`sdiv`就是一个`SDNode`的实例化，`SDTFPBinOp`是类型约束，也在这个文件中定义：
```c++
def SDTIntBinOp : SDTypeProfile<1, 2, [
  SDTCisSameAs<0, 1>, SDTCisSameAs<0, 2>, SDTCisInt<0>
]>;
```

表明它有一个输出, 两个输入, 限制`result`和两个操作数类型相同并是`int`。“ISD::SDIV”是它的opcode，在`llvm/include/llvm/CodeGen/ISDOpcodes.h`中定义。
这里定义好sdiv这个SDNode后，在llvm/lib/CodeGen/SelectionDAG/SelectionDAGDumper.cpp中会指定它在dump到SelectionDAG时的操作名:

```cpp
std::string SDNode::getOperationName(const SelectionDAG *G) const {
  switch (getOpcode()) {
  ...
  case ISD::SDIV:  return "sdiv";
```

这里的"sdiv"就是我们打印出的文件中的sdiv。

如果将这步的SelectionDAG画出来就是如下图，它和log文件里是保持一致的，篇幅限制后面就不放图了。

![img](https://pic1.zhimg.com/80/v2-9b1f4a7ef00bd7b38f3621fc64bd7468_720w.webp)

\2. 合法化之前的优化

这个例子在合法化之前没有什么需要优化的，因此除法仍然被表示为

```text
t5: i32 = sdiv t2, t4
```

\3. 类型合法化

我们的例子中使用直接支持的int32类型，因此这里也没有什么要做的。

\4. 操作合法化

这个步骤会把一些不合法的操作转换成合法的，这个步骤后，我们的除法操作变成了：

```text
t9: i32,i32 = sdivrem t2, t4
```

这个转换的发生，是因为Cpu0不支持我们想要的sdiv对应的指令，所以我们可以在llvm/lib/Target/Cpu0/Cpu0ISelLowering.cpp中找到下列内容:

```text
setOperationAction(ISD::SDIV, MVT::i32, Expand);
```

它表示sdiv这个SDNode在lowering的过程中会被expand，也就是会用其他的SDNode实现，具体替换成什么是llvm自己决定的，对于sdiv它会替换成sdivrem（llvm会把除法和求余都expand成统一的节点），它的定义在

llvm/include/llvm/Target/TargetSelectionDAG.td中：

```text
def sdivrem:SDNode<“ISD::SDIVREM”, SDTFPBinOp>;
```

\5. 合法化之后的优化

在这次优化后，上述形式又变成了这样：

```text
t10: glue=Cpu0ISD::DivRem t2,t4 //glue表示两个节点需要链接到一起，这里连接t10和t12
t12:i32,ch,glue=CopyFromReg t0, Register:i32 $lo, t10
```

这里用两个节点替换了上面的一个节点，并用glue连接，我们可以在llvm/lib/Target/Cpu0/Cpu0ISelLowering.cpp中找到解释:

```text
setTargetDAGCombine(ISD::SDIVREM);
```

它表示sdivrem这个SDNode会被执行DAGCombine，它的具体执行定义也在这个文件中：

```text
static SDValue performDivRemCombine(SDNode *N, SelectionDAG& DAG,
 TargetLowering::DAGCombinerInfo &DCI,
 const Cpu0Subtarget &Subtarget) {
 if (DCI.isBeforeLegalizeOps())
 return SDValue();
 EVT Ty = N->getValueType(0);
 unsigned LO = Cpu0::LO; //低位寄存器
 unsigned HI = Cpu0::HI; //高位寄存器
 unsigned Opc = N->getOpcode() == ISD::SDIVREM ? Cpu0ISD::DivRem : //这里用Cpu0ISD::DivRem表示ISD::SDIVREM
 Cpu0ISD::DivRemU;
 SDLoc DL(N); //Node位置
 SDValue DivRem = DAG.getNode(Opc, DL, MVT::Glue,
 N->getOperand(0), N->getOperand(1));
 SDValue InChain = DAG.getEntryNode(); //控制依赖
 SDValue InGlue = DivRem; //glue胶水，连接DivRem
 // insert MFLO
 if (N->hasAnyUseOfValue(0)) { //除法操作
 SDValue CopyFromLo = DAG.getCopyFromReg(InChain, DL, LO, Ty, InGlue); //调用CopyFromReg这个Node
 DAG.ReplaceAllUsesOfValueWith(SDValue(N, 0), CopyFromLo);
 InChain = CopyFromLo.getValue(1);
 InGlue = CopyFromLo.getValue(2);
 }
 // insert MFHI
 if (N->hasAnyUseOfValue(1)) { //取余操作
 SDValue CopyFromHi = DAG.getCopyFromReg(InChain, DL, HI, Ty, InGlue);
 DAG.ReplaceAllUsesOfValueWith(SDValue(N, 1), CopyFromHi);
 }
 return SDValue();
}
```

上述代码结合注释可以看出sdivrem由Cpu0ISD::DivRem和CopyFromReg结合组成。那么为什么要这么做呢？这是因为Cpu0ISD::DivRem对应的指令（在后面会看到），会将一个除法操作的商放到 LO 寄存器，将余数放到 HI 寄存器（寄存器在Cpu0RegisterInfo.td中定义），因此我们需要从LO寄存器中把值赋值到目标寄存器，就完成了除法操作。

Cpu0ISD::DivRem的返回名称也在这个文件声明：

```text
const char *Cpu0TargetLowering::getTargetNodeName(unsigned Opcode) const {
 switch (Opcode) {
 case Cpu0ISD::DivRem         :  return "Cpu0ISD::DivRem";
```

它的定义则在llvm/lib/Target/Cpu0/Cpu0InstrInfo.td中：

```text
def Cpu0DivRem  : SDNode<"Cpu0ISD::DivRem", SDT_Cpu0DivRem, [SDNPOutGlue]>;
```

"Cpu0ISD::DivRem"这个opcode则在llvm/lib/Target/Cpu0/Cpu0ISelLowering.h中声明。

\6. 指令选择

现在我们可以开始指令选择了，在test.log中会打印出

```text
ISEL: Starting selection on root node: t10: glue = Cpu0ISD::DivRem t2, t4
ISEL: Starting pattern match
  Initial Opcode index to 3066
  Morphed node: t10: i32,glue = SDIV t2, t4
ISEL: Match complete!
```

表示它成功将 Cpu0ISD::DivRem这个SDNode匹配成了SDIV这个Cpu0后端实际支持的指令。我们首先看一下匹配是怎么实现的。SDIV这条真实指令的定义在llvm/lib/Target/Cpu0/Cpu0InstrInfo.td文件中：

```text
def SDIV     : Div32<Cpu0DivRem, 0x43, "div", IIIdiv>;
class Div32<SDNode opNode, bits<8> op, string instrAsm, InstrItinClass itin>
  : Div<opNode, op, instrAsm, itin, CPURegs, [HI, LO]>;
class Div<SDNode opNode, bits<8> op, string instrAsm, InstrItinClass itin,
          RegisterClass RC, list<Register> DefRegs>
  : FA<op, (outs), (ins RC:$ra, RC:$rb), //括号里是输入和输出
       !strconcat(instrAsm, "\t$ra, $rb"), //这里表示对应的在汇编文件中的内容
       [(opNode RC:$ra, RC:$rb)], itin> {  //[]中是匹配的模式
 let rc = 0;
 let shamt = 0;
 let Defs = DefRegs;
}
```

经过几次跳转后我们可以发现SDIV这条指令匹配的模式是(Cpu0DivRem RC:$ra, RC:$rb)（这是一条dag，dag是tablegen中的一种数据类型，可以用来表示SDNode或者指令的匹配形式），恰恰就是我们上面log文件中的格式。这里根据它匹配的模式可以看到，SDIV与在初始SelectionDAG构建时的sdiv操作形式是不一样的，SDIV没有返回值， 根据Cpu0的ISA文档可以得知它将除法的商放到 LO 寄存器，将余数放到 HI 寄存器:

| Format | Mnemonic | Opcode | Meaning        | Syntax     | Operation            |
| ------ | -------- | ------ | -------------- | ---------- | -------------------- |
| A      | DIV      | 43     | Divide         | DIV Ra, Rb | HI<=Ra%Rb, LO<=Ra/Rb |
| A      | MFLO     | 47     | Move LO to GPR | MFLO Ra    | Ra <= LO             |

；而sdiv直接返回商，因此不能将sdiv直接匹配到SDIV指令，需要在上面操作合法化时处理sdiv。匹配之后的除法运算的SelectionDAG表示为:

```text
t10: i32, glue=SDIV t2, t4 
t12: i32, ch, glue = CopyFromReg t0, Register:i32 $lo, t10:1
```

这里我们发现t12节点没有被匹配，但是通过上面Cpu0的ISA文档可以发现，它有一条指令叫MFLO，作用就是将LO寄存器的值取出到通用寄存器，和我们t12节点作用是一样的，那么为什么这里没有选择这个指令呢，我们看下MFLO指令的定义便可知道，在llvm/lib/Target/Cpu0/Cpu0InstrInfo.td中可以看到：

```text
def MFLO     : MoveFromLOHI<0x47, "mflo", CPURegs, [LO]>;
class MoveFromLOHI<bits<8> op, string instrAsm, RegisterClass RC,
                   list<Register> UseRegs>
  : FA<op, (outs RC:$ra), (ins),
       !strconcat(instrAsm, "\t$ra"), [], IIHiLo> {
  let rb = 0;
  let rc = 0;
  let shamt = 0;
  let Uses = UseRegs;
  let hasSideEffects = 0;
}
```

而FA的定义在llvm/lib/Target/Cpu0/Cpu0InstrFormats.td:

```text
class FA<bits<8> op, dag outs, dag ins, string asmStr,
 list<dag> pattern, InstrItinClass itin>
  : Cpu0Inst<outs, ins, asmStr, pattern, itin, FrmA>
{
...
}
```

根据传过来的参数，我们可以发现它的pattern是空的，也就是没有定义和他匹配的dag，那么在指令选择的时候也就不会被选择成MFLO。

最终指令选择后对应的machine code为：

```text
SDIV %0:cpuregs, %1:cpuregs, implicit-def dead $hi, implicit-def $lo
%2:cpuregs = COPY $lo
$v0 = COPY %2:cpuregs
```

CopyFromReg的选择会在之后发生。因为CopyFromReg或CopyToReg这种是针对寄存器的操作，在指令选择时的寄存器都是虚拟寄存器，而在寄存器分配之后，会分配物理寄存器，并且根据实际分配的类型进行一些优化，比如从在同一个寄存器进行Copy会被优化掉，因此我们这里CopyFromReg映射到MFLO的过程也在寄存器分配之后的步骤中进行。

\7. 生成汇编

我们执行下面的命令来生成汇编代码：

```text
llc -O2 -march=cpu0 test.ll -o test.s
```

在最终的代码文件中我们可以看到除法操作最终被映射成了以下指令：

```text
div $4, $5  //sdiv指令对应的汇编string
mflo    $2
```

汇编中的string内容在指令定义的时候已经提供了。那么MFLO指令是怎么转换得来的呢，我们再执行以下命令来打印出各个pass前后的表示形式：

```text
llc -march=cpu0 -O2 -print-after-all -print-before-all  test.ll >test.log2 2>&1 
```

在test.log2文件中，和我们指令选择无关的结果我们就不看了。而我们会看到在 Post-RA pseudo instruction expansion pass 前后，CopyFromReg对应的Copy机器码被转换为了MFLO指令：

```text
# *** IR Dump Before Post-RA pseudo instruction expansion pass ***: 
...
  SDIV killed $a0, killed $a1, implicit-def dead $hi, implicit-def $lo
  $v0 = COPY killed $lo
...
# *** IR Dump After Post-RA pseudo instruction expansion pass ***:
...
  SDIV killed $a0, killed $a1, implicit-def dead $hi, implicit-def $lo
  $v0 = MFLO implicit $lo
...
```

这里Post-RA就说明了是寄存器分配之后的pass，我们找到Post-RA pseudo instruction expansion 这个pass对应的文件llvm/lib/CodeGen/ExpandPostRAPseudos.cpp，会发现以下内容：

```text
bool ExpandPostRA::LowerSubregToReg(MachineInstr *MI) {
...
TII->copyPhysReg(*MBB, MI, MI->getDebugLoc(), DstSubReg, InsReg,
                     MI->getOperand(2).isKill());
...
```

而Cpu0的copyPhysReg函数定义在llvm/lib/Target/Cpu0/Cpu0SEInstrInfo.cpp文件中：

```text
void Cpu0SEInstrInfo::copyPhysReg(MachineBasicBlock &MBB,
 MachineBasicBlock::iterator I,
 const DebugLoc &DL, unsigned DestReg,
  unsigned SrcReg, bool KillSrc) const {
 unsigned Opc = 0, ZeroReg = 0;
 if (Cpu0::CPURegsRegClass.contains(DestReg)) { // Copy to CPU Reg
 if (Cpu0::CPURegsRegClass.contains(SrcReg))
 Opc = Cpu0::ADDu, ZeroReg = Cpu0::ZERO;
 else if (SrcReg == Cpu0::HI)
 Opc = Cpu0::MFHI, SrcReg = 0;
 else if (SrcReg == Cpu0::LO) //这里表明了如果copy操做的源寄存器是LO，那么就会lower成MFLO指令
 Opc = Cpu0::MFLO, SrcReg = 0;
 }
...
```

copy操作在这里统一进行了转换。

到这里，一条除法操作在LLVM指令选择中的大致的变化过程就结束了。